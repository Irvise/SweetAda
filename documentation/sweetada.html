<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This manual is for SweetAda.

Copyright (C) 2020, 2021, 2022 Gabriele Galeotti
 -->
<title>SweetAda</title>

<meta name="description" content="SweetAda">
<meta name="keywords" content="SweetAda">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="#Top" rel="start" title="Top">
<link href="#Index" rel="index" title="Index">
<link href="#Overview" rel="next" title="Overview">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">SweetAda</h1>





<div class="top" id="Top">
<div class="header">
<p>
Next: <a href="#Overview" accesskey="n" rel="next">Overview</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="SweetAda"></span><h1 class="top">SweetAda</h1>


<ul class="section-toc">
<li><a href="#Overview" accesskey="1">Overview</a></li>
<li><a href="#Overall-structure" accesskey="2">Overall structure</a></li>
<li><a href="#Host-environment" accesskey="3">Host environment</a></li>
<li><a href="#Toolchains" accesskey="4">Toolchains</a></li>
<li><a href="#Toolchain-tools" accesskey="5">Toolchain tools</a></li>
<li><a href="#Emulators" accesskey="6">Emulators</a></li>
<li><a href="#Menu-front_002dends" accesskey="7">Menu front-ends</a></li>
<li><a href="#Building-the-RTS" accesskey="8">Building the RTS</a></li>
<li><a href="#Configuration" accesskey="9">Configuration</a></li>
<li><a href="#Makefile-targets">Makefile targets</a></li>
<li><a href="#Ada-environment">Ada environment</a></li>
<li><a href="#GPRbuild-mode">GPRbuild mode</a></li>
<li><a href="#Building-SweetAda">Building SweetAda</a></li>
<li><a href="#Anatomy-of-a-platform">Anatomy of a platform</a></li>
<li><a href="#The-core-complex">The core complex</a></li>
<li><a href="#LibGCC">LibGCC</a></li>
<li><a href="#Optimizations">Optimizations</a></li>
<li><a href="#Platform-descriptions">Platform descriptions</a></li>
<li><a href="#IOEMU-scripting">IOEMU scripting</a></li>
<li><a href="#References">References</a></li>
<li><a href="#Index">Index</a></li>
</ul>
<hr>
<div class="chapter" id="Overview">
<div class="header">
<p>
Next: <a href="#Overall-structure" accesskey="n" rel="next">Overall structure</a>, Previous: <a href="#Top" accesskey="p" rel="prev">SweetAda</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Overview-1"></span><h2 class="chapter">1 Overview</h2>
<span id="index-Overview"></span>

<p>Welcome to SweetAda.
</p>
<p>SweetAda is an Ada-based development environment suitable to build lightweight applications
in CPU-driven electronic devices. Developed from scratch with simplicity in mind,
SweetAda tries to fill the gap between a simple, yet reliable, software/firmware control
system and big, complex, OS-based multitasked environment.
</p>
<hr>
</div>
<div class="chapter" id="Overall-structure">
<div class="header">
<p>
Next: <a href="#Host-environment" accesskey="n" rel="next">Host environment</a>, Previous: <a href="#Overview" accesskey="p" rel="prev">Overview</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Overall-structure-1"></span><h2 class="chapter">2 Overall structure</h2>

<p>The SweetAda system is composed of a top-level directory which holds other directories
and software components. They are:
</p><ul>
<li> application<br>
generic user code
</li><li> clibrary<br>
small-size C library
</li><li> core<br>
machine-independent core software
</li><li> cpus<br>
machine-dependent CPU low-level library
</li><li> drivers<br>
I/O and peripherals components
</li><li> freeze<br>
test tool to compare two builds
</li><li> libutils<br>
scripts and support utilities
</li><li> modules<br>
various high-level libraries
</li><li> obj<br>
build system output files
</li><li> platforms<br>
platform-dependent low-level library
</li><li> rts<br>
Ada Run-Time System
</li><li> share<br>
common auxiliary files
</li></ul>

<hr>
</div>
<div class="chapter" id="Host-environment">
<div class="header">
<p>
Next: <a href="#Toolchains" accesskey="n" rel="next">Toolchains</a>, Previous: <a href="#Overall-structure" accesskey="p" rel="prev">Overall structure</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Host-environment-1"></span><h2 class="chapter">3 Host environment</h2>

<p>SweetAda is meant to run on major 64-bit mainstream environments, i.e., modern installation of
POSIX/Linux, Windows, or OS X.
</p>
<p>SweetAda requires installation of GNU toolchains, and is based on GNU Make, plus some little
utilities. The OS should be able to create symbolic links.
</p>
<p>In the following chapters, operations in a POSIX machine will be described when doing examples,
unless otherwise noted.
</p>
<ul class="section-toc">
<li><a href="#General-advices" accesskey="1">General advices</a></li>
<li><a href="#Installation-prerequisites" accesskey="2">Installation prerequisites</a></li>
<li><a href="#Testing-the-installation" accesskey="3">Testing the installation</a></li>
<li><a href="#Environment-notes" accesskey="4">Environment notes</a></li>
</ul>
<div class="section" id="General-advices">
<h3 class="section">3.1 General advices</h3>
<span id="index-General-advice"></span>

<p>It is highly advisable to perform commands in the SweetAda top-level directory (which exists
as a variable SWEETADA_PATH in the build system). The Makefile machinery is able to infer the
SweetAda path from the context, but this feature relies on standard Makefile idioms which could
be invalidated by an &quot;esotic&quot; environment setup.
</p>
<p>Hence, if you want to integrate SweetAda in a GUI, the glue logic should change the working
directory before performing an action.
</p>
<p>Note for Windows users:
Many operations in SweetAda could need variables inherited from the environment; pay
attention when setting variables in the command line shell, i.e. when you are concatenating
many assignments use always double-quotes to protect arguments:
</p>
<p>&gt; SET &quot;&lt;variable_name&gt;=&lt;variable_value&gt;&quot; &amp;&amp; SET &quot;...
</p>
<p>Also be sure to run commands in a shell with Administrator privileges, because some
operations (like creating symbolic links) require elevation rights.
</p>
</div>
<div class="section" id="Installation-prerequisites">
<h3 class="section">3.2 Installation prerequisites</h3>
<span id="index-Installation-prerequisites"></span>

<p>SweetAda requires some support from the OS environment. Apart the standard low-level
utilities, like shell command/programs to copy or move files and other usual filesystem
operations, the GNU Make is the fundamental component that drives the whole SweetAda
build process.
</p>
<p>GNU sed is a small utility to perform simple textual processing, and it used to filter
strings and files should the shell have not enough computational power to perform
these basic activities.
</p>
<p>In some environments (Linux, and, if properly configured, also OS X) the GNU Make and
sed utilities are natively present and there is no need to install them or specify theirs
location in the filesystem, but this is not true under Windows and thus should be
installed by means of thirdy-party packages. If you do not have these utilities available,
please install them from your package provider, or download them from the SweetAda
SourceForge repository. Remember, as a rule of thumb, to put the filesystem executable
path in the visible part of the PATH environment variable which is then parsed by the shell.
GNU Make must be immediately available since there is no point in running a Makefile
without the GNU Make interpreter. The GNU sed utility could be installed directly in the
&quot;libutils&quot; directory without the need to modify the environment setup.
</p>
<p>SweetAda also requires (although they are not really strictly necessary from a system
standpoint) three auxiliary programs, i.e, the GCC/GNAT wrappers and the elftool utility.
They are provided as source programs to be built in the libutils/toolchain_tools directory.
You need a system GCC compiler available online if you want to change their behaviour
(which is not recommended, though). See <a href="#Toolchain-tools">Toolchain tools</a>.
</p>
<p>The GCC wrapper is a small piece of code that sits between the compiler driver and the
compiler executable. It analyzes command line parameters, selects verbosity level and
instructs the compiler executable to generate additional output files, like assembler
listing and Ada expanded source code. There is a companion wrapper, the &quot;GNAT wrapper&quot;,
but its use is limited to print brief informations when GNATMAKE processes with&rsquo;ed units.
</p>
<p>elftool is a small utility that dumps the output object code. It is used mainly for a
clean visual output in order to easily parse ELF sections. elftool is anyway optional,
and you can avoid its use by setting a variable in the top-level configuration.in file,
so the standard &quot;size&quot; toolchain executable is thus used.
</p>
<p>runsweetada is a small front-end scripting utility to ease the execution of a SweetAda,
mostly used with virtual targets that use an emulator like QEMU.
</p>
<p>All these utilities can be downloaded as executables from the SweetAda SourceForge
repository. See <a href="#References">References</a>. Browse for the directory corresponding to your environment
and select the last archive available. Except GNU Make, which should be installed in a
PATH-visible directory, all other utilities could be installed in the &quot;libutils&quot;
subdirectory of the SweetAda filesystem hierarchy.
</p>
</div>
<div class="section" id="Testing-the-installation">
<h3 class="section">3.3 Testing the installation</h3>
<span id="index-Testing-the-installation"></span>

<p>In order to perform actions, the GNU Make interpreter should be invoked, followed by the
target, like in:
</p>
<div class="example">
<pre class="example">$ make configure
</pre></div>

<p>(provided your working directory is the SweetAda top-level-directory).
</p>
<p>The two shell scripts menu.sh (Bash) and menu.bat (Windows cmd.exe) are useful to ease
the invocation of the GNU Make executable provided in the toolchain package. Thus, eventually
adjust the script near the &quot;Main loop&quot; entry point, as shown in the next lines:
</p>
<div class="example">
<pre class="example">menu.bat:
REM defaults to standard installation directory, see configuration.in
SET MAKEEXE=&quot;C:\Program Files\SweetAda&quot;\bin\make.exe                  &lt;---
</pre></div>

<div class="example">
<pre class="example">menu.sh:
...
  darwin)
    # use SweetAda GNU Make (try a standard installation prefix)
    SWEETADA_MAKE=/opt/sweetada/bin/make                     &lt;---
...
  msys)
    # use SweetAda GNU Make (try a standard installation prefix)
    SWEETADA_MAKE=&quot;/c/Program Files/SweetAda/bin/make.exe&quot;   &lt;---
</pre></div>

<p>Once the script is properly adjusted, just execute the script by specifying the desired
action, like as a Makefile invocation:
</p>
<div class="example">
<pre class="example">$ ./menu.sh help
</pre></div>

<p>or:
</p>
<div class="example">
<pre class="example">&gt; menu.bat help
</pre></div>

<p>If everything is working fine, you should see the help from the master Makefile:
</p>
<div class="example">
<pre class="example">make help (default)
  Display an help about make targets.
make CPU=&lt;cpu&gt; [CPU_MODEL=&lt;cpu_model&gt;] RTS=&lt;rts&gt; [TOOLCHAIN_NAME=&lt;toolchain_name&gt;] rts
  Create RTS &lt;rts&gt; for CPU &lt;cpu&gt; with toolchain &lt;toolchain_name&gt;.
make PLATFORM=&lt;platform&gt; [SUBPLATFORM=&lt;subplatform&gt;] createkernelcfg
  Create the 'kernel.cfg' main configuration file.
make configure
  Create configuration/support files for this platform.
make all
  Perform the same as 'make kernel'.
make kernel
  Build the kernel binary output file 'kernel.o'.
make postbuild
  Perform platform-specific finalizations and create a physical kernel file 'kernel.rom'.
make session-start
  Perform session start activities.
make session-end activities
  Perform session end activities.
make run
  Run the kernel.
make debug
  Run the kernel with debugger active.
make infodump
  Dump essential informations.
make kernel_libinfo
  Generate library informations.
make kernel_info
  Generate kernel informations.
make clean
  Clean object files.
make distclean
  Clean object files and all configuration/support files.
make probevariable PROBEVARIABLE=&lt;variablename&gt;
  Obtain the value of a variable.
Available CPUs: AArch64 ARM AVR M68k MIPS MicroBlaze NiosII PowerPC RISC-V SPARC SuperH System390 x86 x86-64
Available RTSes: sfp zfp
Available Platforms: ATmega128_MinimalDevelopmentBoard Altera10M50GHRD Amiga-FS-UAE ArduinoUNO Atlas CobaltRaQ2 DE10-Lite DECstation5000.133 DigiConnectME Dreamcast FRDM-KL46Z GEMI HiFive1 IntegratorCP LEON3 M5235BCC ML605 MPC8306-SOM MPC8306-Switch MPC8315e MSP432P401R MVME162-510A Malta MemecFX12 OPTi386WB PC-x86 PC-x86-64 QEMU-AArch64 QEMU-AVR QEMU-MIPS QEMU-RISC-V-32 QEMU-i486 RaspberryPi3 SBC5206 SPARCstation5 STM32F769I Spartan3A-EK Spartan3E-SK Synergy-S5D9 System390 Taihu Template TestPlatform XilinxZynqA9 ZOOM
</pre></div>

</div>
<div class="section" id="Environment-notes">
<h3 class="section">3.4 Environment notes</h3>
<span id="index-Environment-notes"></span>

<p>SweetAda supports whitespaces in filepaths although this is considered bad practice.
</p>
<hr>
</div>
</div>
<div class="chapter" id="Toolchains">
<div class="header">
<p>
Next: <a href="#Toolchain-tools" accesskey="n" rel="next">Toolchain tools</a>, Previous: <a href="#Host-environment" accesskey="p" rel="prev">Host environment</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Toolchains-1"></span><h2 class="chapter">4 Toolchains</h2>
<span id="index-toolchains"></span>

<p>The SweetAda system is distributed with GNU toolchains for every CPU it can handle.
Altough toolchains are quite generic, SweetAda does not employ neither the whole standard
GNU FSF RTS source package nor the LibGCC library.
</p>
<p>The SweetAda RTS is a ZFP/SFP run-time that avoid to include subprograms from the original
implementation, which is quite big and requires an underneath operating system.
</p>
<p>The LibGCC library, which is present like in every other standard toolchain, is bypassed
and partially reimplemented in Ada. Only some low-level machine-language files are required,
carefully extracted from the LibGCC sources. This way, you have a system which is under
your complete control at the source level, and every bit of information is known.
Code output by the build system is thus coming directly from the compiler, without extra
source files inclusion. Anyway, the standard LibGCC binaries can be selected with a
configuration variable.
</p>
<p>GNU toolchains are referenced by a &quot;canonical triplet&quot;, e.g. &quot;i686-unknown-linux&quot;; since
this name identifies also a working directory component of the toolchain, every time we
refer to a toolchain this string should be used, like stating the current toolchain
in the main configuration.in.
</p>
<hr>
</div>
<div class="chapter" id="Toolchain-tools">
<div class="header">
<p>
Next: <a href="#Emulators" accesskey="n" rel="next">Emulators</a>, Previous: <a href="#Toolchains" accesskey="p" rel="prev">Toolchains</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Toolchain-tools-1"></span><h2 class="chapter">5 Toolchain tools</h2>
<span id="index-GCC-wrapper"></span>
<span id="index-GNAT-wrapper"></span>
<span id="index-elftool"></span>
<span id="index-runsweetada"></span>

<p>SweetAda is not tied to SweetAda toolchains, and can be used with your own GNU toolchain.
</p>
<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
GNU toolchains should provide GNATCHOP, GNATLS, GNATMAKE, GNATBIND, GNATLINK,
GNATPREP, GNATXREF executables.
</p></td></tr></table>

<p>Anyway, SweetAda needs two small utilities, a GNATMAKE wrapper and a GCC wrapper,
that could be built from sources if you have a C compiler available online. The current
setup is for a system GCC C compiler.
</p>
<p>Go into the directory libutils/toolchain_tools and edit the Makefile by adjusting some
variables:
</p>
<div class="example">
<pre class="example">CC      := gcc # C compiler
LIBELF  := /usr/local/lib/libelf.a # location of libelf library
</pre></div>

<p>For elftool, you sould have libelf installed in your environment setup, but it is not
strictly needed. Remember that GNU toolchain installation prefixes refers to the whole
hierarchy, so do not add a trailing &quot;/bin&quot;.
</p>
<p>Then, after a proper Makefile setup:
</p>
<div class="example">
<pre class="example">$ make wrappers
$ make install-wrappers
</pre></div>

<p>will build and install wrappers,
</p>
<div class="example">
<pre class="example">$ make all
$ make install
</pre></div>

<p>will build and install wrappers and elftool.
</p>
<p>This procedure should work also on a Windows cmd.exe shell, provided you have the
GNU Make utility available online.
</p>
<p>runsweetada is a scripting utility coupled with the IOEMU I/O emulator, which is an
extension to QEMU, FS-UAE or GXemul. See <a href="#IOEMU-scripting">IOEMU scripting</a>. Its purpose is to
centralize the startup of executables so to not have multiple scripts laying around
in the filesystem. When your target platform is an emulator, it is the perfect
place to put filesystem operations and options, but it does work also as a generic
execution front-end. runsweetada has a few command line parameters:
</p>
<div class="example">
<pre class="example">-d &lt;variable&gt;[=value]
define an environment variable

-f &lt;filename&gt;
read configuration file name &lt;filename&gt; (default = &quot;sweetada.cfg&quot;)

-k &lt;path&gt;
define SWEETADA_PATH=&lt;path&gt; (default = current directory)

-p &lt;directory&gt;
define PLATFORM_DIRECTORY=&lt;directory&gt; (default = &quot;.&quot;)

Currently there is no source code for runsweetada because it is under heavy
redesign.
</pre></div>

<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
The Makefile that drives all SweetAda operations executes user commands (e.g.,
&quot;run&quot;) in the top-level directory, so if you want to perform operations in the
platform directory, remember to change the working directory in the runsweetada
script with a &quot;CHDIR&quot; command placed in the &quot;START&quot; section.
</p></td></tr></table>

<hr>
</div>
<div class="chapter" id="Emulators">
<div class="header">
<p>
Next: <a href="#Menu-front_002dends" accesskey="n" rel="next">Menu front-ends</a>, Previous: <a href="#Toolchain-tools" accesskey="p" rel="prev">Toolchain tools</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Emulators-1"></span><h2 class="chapter">6 Emulators</h2>
<span id="index-Emulators"></span>

<p>SweetAda does use emulators in order to test the code without the need of physical
hardware. Three emulators are being provided at least on a Linux machine: QEMU (generic
for nearly all targets), FS-UAE (for Amiga machines) and GXemul (for the Dreamcast
console). Note that FS-UAE and GXemul are only provided for Linux machines.
</p>
<p>When installing an emulator package, pay attention to the top-level directory hierarchy
of the archive, because it refers to the root directory of the machine filesystem. Hence,
unpack them referring to, say, &quot;C:&quot; or &quot;/&quot;.
</p>
<hr>
</div>
<div class="chapter" id="Menu-front_002dends">
<div class="header">
<p>
Next: <a href="#Building-the-RTS" accesskey="n" rel="next">Building the RTS</a>, Previous: <a href="#Emulators" accesskey="p" rel="prev">Emulators</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Menu-front_002dends-1"></span><h2 class="chapter">7 Menu front-ends</h2>
<span id="index-Menu-front_002dends"></span>

<p>SweetAda has three shell utilities to ease invoking the GNU Make interpreter.
</p>
<p>&quot;menu.sh&quot; is a pure Bash script.
</p>
<p>&quot;menu-dialog.sh&quot; is a Bash script for machines which have the dialog utility
available.
</p>
<p>&quot;menu.bat&quot; is a cmd.exe Windows script.
</p>
<p>Bash menus are able to produce logfiles of a SweetAda build, just set VERBOSE=1
before running them if you want a detailed description of the operations performed
by the build engine.
</p>
<p>Note that only kernel build actions are logged, so, if you give directly a &quot;run&quot;
action instead of the more correct sequence &quot;all, run&quot;, then no log files will be
produced.
</p>
<hr>
</div>
<div class="chapter" id="Building-the-RTS">
<div class="header">
<p>
Next: <a href="#Configuration" accesskey="n" rel="next">Configuration</a>, Previous: <a href="#Menu-front_002dends" accesskey="p" rel="prev">Menu front-ends</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Building-the-RTS-1"></span><h2 class="chapter">8 Building the RTS</h2>
<span id="index-RTS"></span>

<p>The very first action to perform after an installation is to build the Ada Run-Time
System.
</p>
<p>The RTS is being built by means of a Makefile target:
</p>
<div class="example">
<pre class="example">$ make CPU=&lt;cpu&gt; [CPU_MODEL=&lt;cpu_model&gt;] RTS=&lt;rts&gt; [TOOLCHAIN_NAME=&lt;toolchain_name&gt;] rts
</pre></div>

<p>For example:
</p>
<div class="example">
<pre class="example">$ make CPU=x86 RTS=sfp TOOLCHAIN_NAME=i686-sweetada-elf rts
$ make CPU=SuperH CPU_MODEL=SH7032 RTS=zfp TOOLCHAIN_NAME=sh-sweetada-elf rts
</pre></div>

<p>Please note that:
</p><ul>
<li> both CPU name and RTS name are one of those listed in the help output from Makefile
</li><li> the trailing &quot;rts&quot; token is the Makefile target just invoked
</li><li> TOOLCHAIN_NAME (the classical triplet name of a toolchain) is mandatory because the
RTS hierarchy should be partitioned in case more than one target CPU should be employed;
this name has to be exactly the same as the toolchain prefix of the executables also
specified in the top-level configuration.in
</li><li> &quot;CPU_MODEL&quot; has meaning only for Hitachi SuperH CPUs, current choices are &quot;SH7032&quot; or
&quot;SH7750&quot;; the CPU_MODEL specification is ignored for every other CPU
</li></ul>

<p>This will build the RTS. If you do not specify the toolchain in the classic &quot;canonical
triplet name form&quot; (e.g., &quot;arm-unknown-eabi&quot;), then the toolchain found in the mapping
of the top-level configuration.in will be used.
</p>
<p>Once you have built the RTS, it is persistent, and you don&rsquo;t need to repeat this
operation, unless you modify RTS source files.
</p>
<p>Supported CPUs are in the rts/src/targets directory. Every CPU directory contains
some Makefile fragments, and the Makefile.rts.in, which is used to state GCC switches
used during the compilation. Remember that no CPU switches should be used, because the
build system compiles the RTS for every CPU configuration, so you should specify only
global features, like, e.g., use of global pointers or object symbol naming.
</p>
<p>SweetAda comes with two RTSes, a ZFP and an SFP. The RTS which will be used is
configurable in the top-level configuration.in file. A proper profile should be
coupled along the RTS type, which configures system-wide pragmas (which are in turn
configurable by means of the gnat.adc.in configuration template).
</p>
<hr>
</div>
<div class="chapter" id="Configuration">
<div class="header">
<p>
Next: <a href="#Makefile-targets" accesskey="n" rel="next">Makefile targets</a>, Previous: <a href="#Building-the-RTS" accesskey="p" rel="prev">Building the RTS</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Configuration-1"></span><h2 class="chapter">9 Configuration</h2>
<span id="index-configuration"></span>

<p>SweetAda configuration is managed by a central Makefile, which loads configuration files
in sequential steps.
</p>
<p>Configuration of SweetAda is done mainly with the help of two configuration files: &quot;main&quot;
(or &quot;system&quot;) configuration file, and a &quot;platform&quot; configuration file. The main configuration
file (located in the top-level directory) defines general, target-agnostic characteristics,
like stating Ada95 or Ada2012 mode, the optimization level, and so on; the platform configuration
file (located in the platform&rsquo;s directory) defines in greater detail how the target software
is going to be generated, and various parameters affecting low-level behaviour.
</p>
<p>Both files are, as a matter of fact, Makefile fragments that are going to be incorporated in
the build system at compile-time. Being the SweetAda build system based on GNU Make, many
facilitations are possible (like variable substitutions) and, if correctly arranged,
configuration items can be made modular and easily changeable.
</p>
<p>The final output product of SweetAda compilation is the file &quot;kernel.o&quot;. Its format depends
on the type of toolchain used, but it is almost exclusively an ELF-class object file.
</p>
<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
The SweetAda build machinery is Makefile-based, but you can also use an alternate
GPR-style build model &ndash; this is enabled by a configuration variable.
</p></td></tr></table>

<p>The master Makefile try to detect the type of machine it is running on, and configuration
of SweetAda begins by reading the system configuration file &quot;configuration.in&quot;.
</p>
<p>Essential variables are set to a default value, like the path to the toolchain prefix,
the build model, RTS type, profile, and so on.
</p>
<p>One important aspect is that configuration variables could be introduced (and could
override pre-defined ones) at various stages of the configuration. Obviously, further
and more specific configuration files are loaded in sequence from the very few basic
information found in the top-level configuration.in.
</p>
<p>Then, if it exists, a &quot;kernel.cfg&quot; file from the top-level directory is loaded.
kernel.cfg contains the hardware platform which will be the build target. If kernel.cfg
is missing, you can specify the platform (and eventually the subplatform) by assigning
the shell environment variables PLATFORM and SUBPLATFORM, which in that case take
precedence over an existing file. PLATFORM should be a valid directory in the &quot;platforms&quot;
subdirectory, and SUBPLATFORM should be a valid subdirectory of the PLATFORM directory,
named &quot;platform-&lt;SUBPLATFORM&gt;&quot;.
</p>
<div class="example">
<pre class="example">$ PLATFORM=PC-x86 SUBPLATFORM=QEMU-ROM make createkernelcfg
</pre></div>

<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
In a &quot;cmd.exe&quot; shell you have to use a &quot;SET&quot; command.
</p></td></tr></table>

<p>Once you choose a platform, you can create the kernel.cfg with the Makefile auxiliary
target &quot;createkernelcfg&quot;.
</p>
<p>Following this command, you can check the presence of a correct kernel.cfg file.
The contents of kernel.cfg will be something like:
</p>
<div class="example">
<pre class="example">PLATFORM := PC-x86
SUBPLATFORM := QEMU-ROM
</pre></div>

<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
You can create the kernel.cfg by hand and skip the createkernelcfg Makefile target.
</p></td></tr></table>

<p>Once kernel.cfg does exist, it will be used until you issue a &quot;make distclean&quot; command,
which erases every configuration file and objects from last compilation.
</p>
<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
Issuing a new configuration erases the old one by executing an implicit &quot;distclean&quot;
Makefile target.
</p></td></tr></table>

<p>After the top-level configuration file is loaded, and thus Makefile knows the platform,
the configuration.in found in that directory is loaded (e.g., ./platforms/ML605/configuration.in).
Here you can specify nearly everything about the target machine, like the CPU model,
fine-tuning compiler switches, run- or debug-related auxiliary scripts, and so on.
If you need to create some information that will be used by external scripts, this is right place.
Pay attention to export every variable you are creating that is not known by the
build system, otherwise the external scripts are not able to access it.
</p>
<div class="example">
<pre class="example">CPU       := x86
CPU_MODEL := i586

GCC_SWITCHES_PLATFORM     += -march=i586 -Wa,-march=i586
LD_SWITCHES_PLATFORM      +=
OBJDUMP_SWITCHES_PLATFORM +=
POSTBUILD_ROMFILE         := Y
OBJCOPY_SWITCHES_PLATFORM += --output-target=binary --gap-fill=0x00

USE_CLIBRARY := Y

USE_APPLICATION := test-PC-x86

ADDITIONAL_OBJECTS += ctest

SESSION_START_COMMAND :=
SESSION_END_COMMAND   :=

RUN_COMMAND   := $(RUNSWEETADA) -k &quot;$(SWEETADA_PATH)&quot; -p &quot;$(PLATFORM_DIRECTORY)&quot; -f qemu.cfg
DEBUG_COMMAND := $(RUN_COMMAND) -d DEBUG_QEMU

export WIRESHARK := /usr/bin/wireshark
</pre></div>

<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
In the example above, we create and export the variable WIRESHARK, which will be used
by the launch script in order to do monitoring of network activity.
</p></td></tr></table>

<p>Having knowledge of the hardware configuration, then the configuration.in in the
appropriate CPU hierarchy is loaded (e.g., cpus/MIPS/configuration.in).
</p>
<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
Once the CPU is well defined, the right files can be taken into account. The standard
toolchain is selected by default, but you can pick another one by, e.g., overriding
the variable TOOLCHAIN_NAME_&lt;CPU&gt; in the configuration.in of the platform directory.
</p></td></tr></table>

<p>Then, the top-level &quot;Makefile.tc.in&quot; file is taken into account. This a very
important part of the global configuration scenario, since it is responsible of the
setup parameters for the compiler toolchain, compilation switches, warning switches
and executable paths. If you want to suppress checks, warnings, or change programming
style layout, you can comment/uncomment the appropriate compiler switch.
</p>
<p>Now that the configuration setup is complete, the build system is ready for the next
step, the configuration target proper.
</p>
<div class="example">
<pre class="example">$ make configure
</pre></div>

<p>The &quot;configure&quot; Makefile target will call the homonym target in every sub-Makefile
concerned, e.g., &quot;core&quot;, &quot;modules&quot;, &quot;drivers&quot;, and the platform. This way, fixing of
files that should be included in the build or a pre-processing from a template file
can take place. As an example, files from SUBPLATFORM specific directory could be
symlinked in the platform set of files, the ?gnat.adc? file will be created from the
template file &quot;gnat.adc.in&quot;, and so on.
</p>
<p>The build system will reply by writing a brief configuration status:
</p>
<div class="example">
<pre class="example">Configuration parameters:
PLATFORM:           PC-x86
SUBPLATFORM:        QEMU-ROM
CPU:                x86
CPU MODEL:          i586
OSTYPE:             linux
SWEETADA PATH:      /root/project/sweetada
TOOLCHAIN PREFIX:   /opt/sweetada
TOOLCHAIN NAME:     i686-sweetada-elf
RTS ROOT PATH:      /root/project/sweetada/rts/sfp/i686-sweetada-elf
RTS PATH:           /root/project/sweetada/rts/sfp/i686-sweetada-elf/.
RTS:                sfp
PROFILE:            sfp
USE LIBADA:         Y
BUILD MODE:         MAKEFILE
OPTIMIZATION LEVEL: 1
MAKE:               make
GCC VERSION:        11.1.0
GCC SWITCHES:       -march=i586 -Wa,-march=i586
GCC MULTIDIR:       .
LD SCRIPT:          linker.lds
LD SWITCHES:        
OBJCOPY SWITCHES:   --output-target=binary --gap-fill=0x00
OBJDUMP SWITCHES:
</pre></div>

<p>The SweetAda Makefile build system can be queried. The special Makefile target
&quot;probevariable&quot; outputs the value of a configuration variable, so, e.g., you can execute a
command line like:
</p>
<div class="example">
<pre class="example">VERBOSE= PROBEVARIABLE=PROFILE make -s probevariable
</pre></div>

<p>and the build system will print the value associated with the variable PROFILE.
A script could intercept the output by means of a redirection and use this information.
Note that the VERBOSE variable is set empty and the the &quot;-s&quot; option is passed down
to the Makefile so the output is not cluttered with other non-interesting output.
</p>
<hr>
</div>
<div class="chapter" id="Makefile-targets">
<div class="header">
<p>
Next: <a href="#Ada-environment" accesskey="n" rel="next">Ada environment</a>, Previous: <a href="#Configuration" accesskey="p" rel="prev">Configuration</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Makefile-targets-1"></span><h2 class="chapter">10 Makefile targets</h2>
<span id="index-Makefile-targets"></span>

<p>Following a &quot;make createkernelcfg&quot; and &quot;make configure&quot;, the build system is ready
to build SweetAda.
</p>
<p>At this point, you should have available the RTS to further proceed with the build.
See <a href="#Building-the-RTS">Building the RTS</a>.
</p>
<p>The next phases will be a &quot;make all&quot; (or &quot;make kernel&quot;) and, optionally, &quot;make postbuild&quot;.
Then SweetAda could be executed by means of the &quot;make run&quot; or &quot;make debug&quot; commands.
</p>
<p>Putting it all together, we can summarize the following fundamental steps:
</p>
<p>1) make createkernelcfg<br>
2) make configure<br>
3) make all<br>
4) make postbuild (if needed)<br>
5) make run/make debug<br>
</p>
<p>Makefile targets have the following properties:
</p><ul>
<li> idempotent
</li><li> the previous target is a prerequisite for the next
</li><li> &quot;make clean&quot; deletes all object files generated
</li><li> &quot;make distclean&quot; invalidates the whole configuration
</li></ul>

<p>Obviously, if you change something in configuration.in files (say, a compiler switch or
the RTS profile), then you should do a &quot;make clean&quot; to rebuild everything. Other heavy
changes may requires a re-configuration from the scratch.
</p>
<p>Makefile targets have also a &quot;localization&quot;. Although handled by the master Makefile,
the functional part is generally encoded in sub-Makefiles rules, either one in a directory
like core, or the cpu one, or the platform one. For example, &quot;make configure&quot; has the
effect of execute the &quot;configure&quot; Makefile target in every component of SweetAda (even
if some components do not need a configuration at all). &quot;make postbuild&quot; is instead
platform-dependent, and thus only the platform&rsquo;s sub-Makefile is called.
</p>
<p>If you want to perform special actions, you could place commands in the corresponding
rule. But a non-intrusive method like calling a script in the RUN_COMMAND specification
of the platform&rsquo;s configuration.in file could be better.
</p>
<hr>
</div>
<div class="chapter" id="Ada-environment">
<div class="header">
<p>
Next: <a href="#GPRbuild-mode" accesskey="n" rel="next">GPRbuild mode</a>, Previous: <a href="#Makefile-targets" accesskey="p" rel="prev">Makefile targets</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Ada-environment-1"></span><h2 class="chapter">11 Ada environment</h2>

<p>The SweetAda build system try to supply a complete environment to build system code for
a target. In order to instruct the compiler, the linker, the binder, and all accompanying
tools, various files exist.
</p>
<p>These files are Makefile.tc.in, Makefile.st.in, Makefile.wr.in and gnat.adc.in.
</p>
<p>Makefile.tc.in is a Makefile fragment that is loaded by the master Makefile and
contains all compilation switches for a toolchain. It, in turn, loads Makefile.st.in
and Makefile.wr.in, other Makefile fragments which contain style switches and warning
switches. There you can selectively comment/uncomment a toolchain switch to suite your
needs.
</p>
<p>For example, if you want to optimize code and reduce the size of the executable, you could
turn off the &quot;-gnatE&quot; switch that enables dynamic checks for access-before-elaboration on
subprogram calls and generic instantiations.
</p>
<p>Anyway, pay attention that these files really should not be seen as configuration files
at will. Be aware that not all the assignments/switches are freely changeable, and some
variables and/or switches are more or less critical to make the toolchain environment
working fine. You should change only switches that not destroy the build flow, e.g.,
it is fine to comment/uncomment a switch like described before, but it is not recommended
to change the &quot;GCC_MULTIDIR&quot; variable, unless you known exactly the underlying logic
behaviour, and thus those variables should be regarded as constants.
</p>
<p>gnat.adc.in is a template for the system-wide Ada &quot;gnat.adc&quot; pragma profile. The pragma
profile is specified in the top-level directory configuration.in by means of the variable
PROFILE.
</p>
<p>When you select a profile, say &quot;zfp&quot;, the build machinery processes this file and
outputs a gnat.adc that contains only the pragmas that carry the selected RTS PROFILE
as dictated in the trailing comment. gnat.adc.in will be processed by the build system
and a gnat.adc useable by the compiler will appear in top-level directory after a
&quot;make configure&quot;.
</p>
<p>So, if you want to include/exclude a pragma, you have to add/remove that profile name in the
trailing comment. As an example, let&rsquo;s say that you want to write something that forces the
compiler to insert implicitly a rather aggressive sequence of instructions (a &quot;trampoline&quot;,
in technical jargon). Let&rsquo;s say that you choose the &quot;sfp&quot; profile (because you have selected
&quot;sfp&quot; as your RTS). Then, gnat.adc.in should be edited in the following way:
</p>
<p>before:
</p>
<div class="example">
<pre class="example">pragma Restrictions (No_Implicit_Dynamic_Code);                         -- zfp sfp
</pre></div>

<p>after
</p>
<div class="example">
<pre class="example">pragma Restrictions (No_Implicit_Dynamic_Code);                         -- zfp
</pre></div>

<p>This way, the gnat.adc output by the build machinery will not contain the pragma, and the
compiler will not complain when it will hit the offending fragment of code.
</p>
<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
You could edit directly the gnat.adc file output by the build system (be sure to clean and
rebuild to make the new pragmas take effect), but the old pragma configuration will be
reinstated if you perform a &quot;make configure&quot; action.
</p></td></tr></table>

<hr>
</div>
<div class="chapter" id="GPRbuild-mode">
<div class="header">
<p>
Next: <a href="#Building-SweetAda" accesskey="n" rel="next">Building SweetAda</a>, Previous: <a href="#Ada-environment" accesskey="p" rel="prev">Ada environment</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="GPRbuild-mode-1"></span><h2 class="chapter">12 GPRbuild mode</h2>
<span id="index-GPRbuild"></span>

<p>The SweetAda build system has two different ways to manage the compilation of the final
executable object; the standard, default one is entirely contained in the various Makefile
files; besides, a second option exists, i,e, using a GPRbuild project file.
</p>
<p>This behaviour is controlled by the variable BUILD_MODE in the top-level configuration.in.
</p>
<p>If you specify BUILD_MODE := GPR, then the Makefile will execute the gprbuild program
(which is a SweetAda package) whilst taking care of system code compilation. In order to do
this, a build.gpr exists in the top-level directory, which will be completed by the
configuration file configure.gpr. configure.gpr is emitted by the &quot;make configure&quot; command
whichever the value of BUILD_MODE is.
</p>
<p>Please note that the GPRbuild mode deals only with Ada &quot;explicit&quot; files. Makefile still
has to take care of low-level files, like assembly startup files and implicit Ada units
that could be not referenced by your code, like memory allocation routines and exceptions
handling. GPRbuild mode indeed manages only the major compilation and binding phase, and
so you have to provide exactly the same sequence of make commands in order to build a
SweetAda executable.
</p>
<hr>
</div>
<div class="chapter" id="Building-SweetAda">
<div class="header">
<p>
Next: <a href="#Anatomy-of-a-platform" accesskey="n" rel="next">Anatomy of a platform</a>, Previous: <a href="#GPRbuild-mode" accesskey="p" rel="prev">GPRbuild mode</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Building-SweetAda-1"></span><h2 class="chapter">13 Building SweetAda</h2>

<p>Once that SweetAda is properly configured and your platform target is known, you can
perform the build of the system:
</p>
<div class="example">
<pre class="example">$ make all
</pre></div>

<p>The final product of the build will be the file &quot;kernel.o&quot;, which contains an ELF object
image of the system code.
</p>
<p>The obj directory contains all object files, assembler listing, expanded Ada code and
.ali libraries produced by the build machinery, together with some support report files,
like .dot and .graph files.
</p>
<p>After the final ELF object is created, you can execute the &quot;postbuild&quot; Makefile target,
which extracts code/data sections from kernel.o, and produces a binary file suitable for
ROM programming, JTAG download, and so on. This target uses the &quot;objcopy&quot; Binutils utility,
so appropriate configuration switches could be selected by means of the OBJCOPY_SWITCHES
variable in the platform&rsquo;s configuration.in file.
</p>
<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
The postbuild target is a two-phase process. The first phase creates a binary
file full of informations, then the postbuild target specified in the platform&rsquo;s Makefile
is executed. This way you can customize the final binary file or take other actions,
like add custom data, place the output file in a server TFTP directory, and so on.
</p></td></tr></table>

<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
Some platforms are virtual, i.e., they use an emulator, and in some cases there is
no need to execute the postbuild target, because the emulator could use directly the
kernel.o file.
</p></td></tr></table>

<hr>
</div>
<div class="chapter" id="Anatomy-of-a-platform">
<div class="header">
<p>
Next: <a href="#The-core-complex" accesskey="n" rel="next">The core complex</a>, Previous: <a href="#Building-SweetAda" accesskey="p" rel="prev">Building SweetAda</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Anatomy-of-a-platform-1"></span><h2 class="chapter">14 Anatomy of a platform</h2>
<span id="index-platform"></span>

<p>In SweetAda a platform is a subdirectory. The platform contains all the files
that are necessary for a target to produce an executable.
</p>
<p>When you are working with a platform, the master Makefile always loads configuration
files from that directory.
</p>
<p>The platform&rsquo;s standard filename for a configuration file is &quot;configuration.in&quot;.
</p>
<p>configuration.in is a Makefile fragment that defines the fundamental characteristics
of the target, like the CPU type, GCC compilation flags, how the build process should
takes place, and so on. Here you can also set your own variables (remember to export
them) to tune the build environment and specify actions. Those variables will be
processed by the master Makefile and will be available in the platform&rsquo;s own Makefile.
</p>
<p>A platform should naturally contain program code files. In SweetAda, some standard
names exist, but you are free to define whatever naming scheme you want. Nearly all
platforms define the following files:
</p>
<ul>
<li> configuration.in<br>
the platform configuration file
</li><li> Makefile<br>
a Makefile which contains some standard targets that will be called from the master
Makefile
</li><li> startup.S<br>
an assembler unit that should phisically setup the target and then pass control to
the main Ada procedure (which then calls the bsp unit)
</li><li> bsp.ad[b|s]<br>
the Ada unit responsible for the high-level setup; ideally, the startup.S will
take the CPU out of reset, configure it in a very basic mode and setup the stack
before calling BSP Ada code
</li><li> llkernel.S<br>
here you can put exception/interrupt handling code (hence the name &quot;low-level&quot;)
</li><li> exceptions.ad[b|s]<br>
the Ada counterpart to llkernel.S
</li><li> configure.ads.in, configure.h.in<br>
these are Ada and Assembler/C files that will be processed when you issue a &quot;make
configure&quot; (that is, after the &quot;createkernelcfg&quot; action); after being processed,
you will find the result, in the form of configure.ads and configure.h, which have
the proper variables put in place once that the master Makefile knows everything
about the platform
</li><li> platform-specific files and Ada units
</li></ul>

<p>The platform Makefile is responsible to compile all the files you need in order to
produce a libplatform.a library that will be linked together all other object files.
If you want to specify your own platform files, simply add them to the OBJECTS
variable, e.g.:
</p>
<div class="example">
<pre class="example">OBJECTS :=

OBJECTS += $(KERNEL_PARENT_PATH)/$(OBJECT_DIRECTORY)/mystartup.o

OBJECTS += $(KERNEL_PARENT_PATH)/$(OBJECT_DIRECTORY)/myllkernel.o

</pre></div>

<p>(Remember to prefix the destination directory).
</p>
<p>The Makefile will then load a common library Makefile (Makefile.lb.in) that will
build the final libplatform.a archive.
</p>
<p>Please note that this scheme exists because the SweetAda compilation model is
partially GNATMAKE-based, but this tool has no knowledge of which object files are
mandatory to be linked into the final executable in order to startup the system.
Briefly stated, everything before the main procedure is foreign code that GNATMAKE
logic cannot have knowledge of.
</p>
<p>Obviously, if you want to write a unit that will be used after that Ada has took
control, then there&rsquo;s no need to specify it in the Makefile, because GNATMAKE will
automatically compile it during the main Ada code translation due to the with clause.
</p>
<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
libplatform (together with libcore and libcpu) objects are, in SweetAda terms, the
so-called &quot;implicit units&quot;, i.e., objects that the Ada compilation system cannot
compute during the build, by analyzing other compilation units.
</p>
<p>Being an implicit unit, however, does not necessarily make a file eligible for
inclusion in the variable &quot;IMPLICIT_ALI_UNITS&quot;, which exists in the master Makefile,
because libplatform files are assembler files that generally do not contribute to
Ada binding phase processing.
</p></td></tr></table>

<hr>
</div>
<div class="chapter" id="The-core-complex">
<div class="header">
<p>
Next: <a href="#LibGCC" accesskey="n" rel="next">LibGCC</a>, Previous: <a href="#Anatomy-of-a-platform" accesskey="p" rel="prev">Anatomy of a platform</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-core-complex-1"></span><h2 class="chapter">15 The core complex</h2>
<span id="index-core"></span>

<p>The core complex is a set of packages that forms the base of subprograms used by
higher level constructs.
</p>
<p>Note that fundamental packages like Bits, LLutils, Memory_Functions, etc, are pragma
Preelaborate, with Bits being pragma Pure.
</p>
<ul>
<li> Bits

<p>Bits is the fundamental package for low-level manipulation. Here you can find many
type declarations and subprograms to handle low-level object.
</p>
</li><li> C library

<p>SweetAda has a very minimalistic C library. This C library takes no active part in
SweetAda. Contrarily to all other environments, where Ada code runs on top of another
piece of software (almost invariably a C-coded OS), in SweetAda even various low-level
functions normally belonging to a standard C library are written in Ada. This small
library exists for reference purposes, and as an aid in porting foreign C user code.
Note that only very basic functions in ctype/stdlib/stdio/string hierarchies are
implemented.
</p>
</li><li> Console

<p>The console package provides basic subprograms to output fundamental
type values on a character-oriented device, like a serial port.
</p>
<p>All the Console subprograms call Print (Character), which takes a descriptor
where you should specify access to a subprogram that does the physical
output. Last_Chance_Handler could use Console, so the package is one of the
implicit units that are linked into the final kernel executables regardless
of a with clause.
</p>
<p>Besides fundamental types output, you can find a Print_Memory subprogram
that is useful to dump a memory section for diagnostic purposes.
</p>
</li><li> GCC_Types

<p>This package implements useful types to handle LibGCC numeric subprograms.
</p>
</li><li> LibGCC

<p>LibGCC package implements pure Ada computation subprograms that are normally
found in the compiler library. They exist mostly as useful references.
</p>
</li><li> LLutils

<p>LLutils package contains useful low-level subprograms that are too much convoluted
to place them in the Bits unit. Besides, this would lead to make Bits non-pure.
</p>
<p>Multibyte swap subprograms are declared here, with Build_Address and its
inverse, Address_Displacement.
</p>
</li><li> Malloc

<p>This package implements a simple memory allocator, and is implicitly used by the
compiler to allocate memory on a pool, e.g., when you call the &quot;new&quot; operator.
BSPs should call the initialization subprogram to reserve memory for the allocator
before the Ada code has a chance to use it. But this could be made automatic by
writing initialization code in the elaboration block of the package.
</p>
</li><li> Memory_Functions

<p>Memory_Functions is a package that provides a pure Ada implementation of the
classical C functions to manipulate memory areas: Memcmp, Memcpy, Memmove,
Memset, Bcopy, Cpymem.
</p>
<p>These subprograms are not optimized, but they are made separate and thus could be
optimized by hand-crafted assembly routines.
</p>
</li><li> MMIO

<p>MMIO package provides unrestricted access to memory with a simple modular-valued
load/store model, thus facilitating handling of low-level objects. Unsigned types
of sizes 8, 16, 32, 64 bits are supported. MMIO standard subprogram bodies are separated,
and can thus be overriden and optimized by instantiating a custom copy (perhaps
coded in native machine language). MMIO have versions for flat, atomic, swapping
and atomic-swapping operations.
</p></li></ul>

<hr>
</div>
<div class="chapter" id="LibGCC">
<div class="header">
<p>
Next: <a href="#Optimizations" accesskey="n" rel="next">Optimizations</a>, Previous: <a href="#The-core-complex" accesskey="p" rel="prev">The core complex</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="LibGCC-1"></span><h2 class="chapter">16 LibGCC</h2>
<span id="index-LibGCC"></span>

<p>Nearly every compiler provides an underlying library for low-level handling
of features which are too expensive to emit code for.
</p>
<p>SweetAda has an integrated copy of the basic routines provided by GCC&rsquo;s LibGCC.
Anyway, there is an equivalent full-Ada implementation in the core complex.
</p>
<p>LibGCC package provides those basic arithmetic operations which are normally
provided by the CPU package or, if explicitly specified, the standard libgcc
library that comes with the GCC compiler. These operations are implemented
in pure Ada as a set of separate subprograms, and then exported so that the linker
can resolve references when the compiler calls them, i.e., a 32-bit x 32-bit
multiplication for a CPU that cannot handle directly.
</p>
<p>It is of rare use, because normally every CPU has its own set of routines.
In SweetAda the LibGCC package is thus more or less a placeholder, in the case of
a port for a new CPU, or experimentation.
</p>
<hr>
</div>
<div class="chapter" id="Optimizations">
<div class="header">
<p>
Next: <a href="#Platform-descriptions" accesskey="n" rel="next">Platform descriptions</a>, Previous: <a href="#LibGCC" accesskey="p" rel="prev">LibGCC</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Optimizations-1"></span><h2 class="chapter">17 Optimizations</h2>
<span id="index-optimizations"></span>

<p>SweetAda provides two mechanisms in order to allow user-defined implementations and
optimizations. The first is to create an alternate piece of code that is going to
replace a standard implementation of some subprograms, the other is to completely override
a unit in the core complex (but not limited to).
</p>
<p>By making some bodies separate and segregate them in a subdirectory creates a first
level of this kind of optimization.
</p>
<p>In a similar way, some package and subprograms can be selected when speed is a priority.
The package MMIO, as an example, exposes a complete range of procedures and functions to
allow low-level I/O, like reading an Unsigned_32 value at a specific address. These
subprograms are written in Ada and are not optimized. Furthermore, they cannot be
inlined and thus can be used as access subprograms to be designated in drivers when you
are configuring the methods to deal with I/O. But some CPU have a subset of MMIO that
overrides the standard one. By rewriting the subprograms with inline assembler instructions,
speed increase could be easily obtained.
</p>
<p>In order to understand those mechanisms, a little bit of knowledge about the dynamic
of the build system will be described.
</p>
<p>When the build system is in action, it computes include directories by assembling strings
of paths, and those paths are read by sequentially including configuration files in the
various subdirectories of the SweetAda system. The order of such reads states the priority
about which units will be processed, since the compiler will pick up the first unit available.
Core SweetAda directories are generally read first, and increasingly low-level directories
are read last, and they could change the previous order, so that, e.g., the target platform
directory will take precedence over the starting one.
</p>
<p>The reading sequence of configuration files is:
</p>
<ul>
<li> application/configuration.in
</li><li> drivers/configuration.in
</li><li> modules/configuration.in
</li><li> core/configuration.in
</li><li> platforms/&lt;PLATFORM&gt;/configuration.in
</li><li> cpus/&lt;CPU&gt;/configuration.in
</li><li> clibrary/configuration.in
</li></ul>

<p>Every configuration file could add its own directory to the list of include directories,
either by head-insertion or tail-insertion (using standard Makefile-syntax variable
assignments), so the precedence schema will be built step-by-step.
</p>
<p>By default, SweetAda uses the following schema, in order of descending priority:
</p>
<ul>
<li> platforms/&lt;PLATFORM&gt;
</li><li> cpus/&lt;CPU&gt;
</li><li> application
</li><li> drivers
</li><li> modules and its subdirectories
</li><li> core and its subdirectories
</li><li> clibrary
</li></ul>

<p>This way, a user-supplied body unit can override a standard one, being the latter a
separate subprogram.
</p>
<p>As an example, a reimplementation of some MMIO subprograms is provided in the
cpus/SPARC directory. The overriding of some standard MMIO subprograms (and only
those explicitly implemented as an optimization) will happen because the
cpus/SPARC/configuration.in specifies the &quot;mmio&quot; subdirectory as an higher-precedence
directory search path that will be head-inserted into the list.
</p>
<p>Another mechanism of optimization is to completely replace the standard SweetAda units.
In order to take gain of this mechanism, the user should take care of implicit units.
</p>
<p>Implicit units, like previously stated, are units that are incorporated in the final
executable regardless of being used. They are a collection of subprograms that are
called by the complier front-end in order to perform low-level activities. Implicit
units are those dealing with:
</p>
<ul>
<li> memory move/copy subprograms
</li><li> memory allocation
</li><li> exception processing
</li></ul>

<p>Great care should be taken in managing those units. Since the user source code
could not referencing this units, the build system have to be aware of the compilation
of those units and theirs dependencies.
</p>
<p>Let&rsquo;s suppose, for example, that you want to do a specific manual handling of
critical activities instead of using the standard last_chance_handler unit. In this
case, you have to rewrite a new unit with the same name and place it in, say,
the platform directory (so that it can take precedence over the core one).
The mandatory steps to perform this overriding are:
</p>
<ul>
<li> 1) specify that you want to override the standard last_chance_handler unit; this
will happen by remove the unit from the list of implicit units in the platform
configuration.in file; this way, the build system will not compile the standard
unit anymore:

<div class="example">
<pre class="example">export IMPLICIT_CORE_UNITS := $(filter-out last_chance_handler,$(IMPLICIT_CORE_UNITS))
</pre></div>

</li><li> 2) still in the platform configuration.in file, reassign the SPEC_* identifier
to the new unit:

<div class="example">
<pre class="example">export SPEC_CORE := $(PLATFORM_DIRECTORY)/last_chance_handler.ads
</pre></div>

</li><li> 3) add the new unit object file to the list of object files in the platform Makefile
(by adding the file to the OBJECTS variable); this way, the build system will
incorporate the new unit in the platform library

<div class="example">
<pre class="example">OBJECTS += $(KERNEL_PARENT_PATH)/$(OBJECT_DIRECTORY)/last_chance_handler.o
</pre></div>

</li><li> 4) still in the platform Makefile, specify the dependencies of the new unit with
standard Makefile syntax, i.e., by enumerating the filenames; implicit units
should be specified in terms of SPEC_* identifiers; this way, the build system will
be triggered by changes in other units

<div class="example">
<pre class="example">$(KERNEL_PARENT_PATH)/$(OBJECT_DIRECTORY)/last_chance_handler.o : $(KERNEL_PARENT_PATH)/$(SPEC_ABORT_LIBRARY)
</pre></div>

<p>(in this example the new unit is with&rsquo;ing Abort_Library, an implicit unit)
</p></li></ul>

<p>The steps 2) and 3) are worth some additional detail:
</p>
<ul>
<li> only non-RTS units should be specified, because RTS units are supposed to be invariant
</li><li> it is necessary to do so because, if the new unit is with&rsquo;ing other implicit units
that are in turn overriden, they could not be detected by the build system
</li><li> whether another implicit unit is being with&rsquo;ed, it is mandatory to use the appropriate
identifier rather than the explicit specification filename; in every case, prepend
the KERNEL_PARENT_PATH path component before the specification
</li></ul>

<p>The identifiers of the implicit units and other dependency units are the followings:
</p>
<ul>
<li> <pre class="verbatim">SPEC_ABORT_LIBRARY              core/abort_library.ads
</pre></li><li> <pre class="verbatim">SPEC_BITS                       core/bits.ads
</pre></li><li> <pre class="verbatim">SPEC_CONSOLE                    core/console.ads
</pre></li><li> <pre class="verbatim">SPEC_CORE                       core/core.ads
</pre></li><li> <pre class="verbatim">SPEC_INTEGER_MATH               core/integer_math.ads
</pre></li><li> <pre class="verbatim">SPEC_LAST_CHANCE_HANDLER        core/last_chance_handler.ads
</pre></li><li> <pre class="verbatim">SPEC_LLUTILS                    core/llutils.ads
</pre></li><li> <pre class="verbatim">SPEC_MALLOC                     core/malloc.ads
</pre></li><li> <pre class="verbatim">SPEC_MEMORY_FUNCTIONS           core/memory_functions.ads
</pre></li></ul>

<hr>
</div>
<div class="chapter" id="Platform-descriptions">
<div class="header">
<p>
Next: <a href="#IOEMU-scripting" accesskey="n" rel="next">IOEMU scripting</a>, Previous: <a href="#Optimizations" accesskey="p" rel="prev">Optimizations</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Platform-descriptions-1"></span><h2 class="chapter">18 Platform descriptions</h2>

<ul class="section-toc">
<li><a href="#Altera-10M50GHRD" accesskey="1">Altera 10M50GHRD</a></li>
<li><a href="#Amiga" accesskey="2">Amiga</a></li>
<li><a href="#Arduino-Uno" accesskey="3">Arduino Uno</a></li>
<li><a href="#Atlas" accesskey="4">Atlas</a></li>
<li><a href="#Terasic-DE10_002dLite" accesskey="5">Terasic DE10-Lite</a></li>
<li><a href="#DECstation-5000_002f133" accesskey="6">DECstation 5000/133</a></li>
<li><a href="#Digi-Connect-ME" accesskey="7">Digi Connect ME</a></li>
<li><a href="#Dreamcast" accesskey="8">Dreamcast</a></li>
<li><a href="#FRDM_002dKL46Z" accesskey="9">FRDM-KL46Z</a></li>
<li><a href="#GEMI">GEMI</a></li>
<li><a href="#SiFive-HiFive-1">SiFive HiFive 1</a></li>
<li><a href="#Integrator_002fCP">Integrator/CP</a></li>
<li><a href="#LEON3">LEON3</a></li>
<li><a href="#M5235BCC">M5235BCC</a></li>
<li><a href="#ML605">ML605</a></li>
<li><a href="#MPC8306-SOM">MPC8306 SOM</a></li>
<li><a href="#MPC8306-Switch">MPC8306 Switch</a></li>
<li><a href="#MPC8315e">MPC8315e</a></li>
<li><a href="#MSP432P401R">MSP432P401R</a></li>
<li><a href="#MVME162_002d510A">MVME162-510A</a></li>
<li><a href="#Malta">Malta</a></li>
<li><a href="#Memec-FX12">Memec FX12</a></li>
<li><a href="#PC_002dx86">PC-x86</a></li>
<li><a href="#PC_002dx86_002d64">PC-x86-64</a></li>
<li><a href="#QEMU-AArch64">QEMU AArch64</a></li>
<li><a href="#QEMU-AVR">QEMU AVR</a></li>
<li><a href="#QEMU-MIPS">QEMU MIPS</a></li>
<li><a href="#QEMU-RISC_002dV-32">QEMU RISC-V 32</a></li>
<li><a href="#REF405EP">REF405EP</a></li>
<li><a href="#Raspberry-Pi-3">Raspberry Pi 3</a></li>
<li><a href="#SBC5206">SBC5206</a></li>
<li><a href="#SPARCstation-5">SPARCstation 5</a></li>
<li><a href="#STM32F769I">STM32F769I</a></li>
<li><a href="#Spartan-3A-EK">Spartan 3A EK</a></li>
<li><a href="#Spartan-3E-SK">Spartan 3E SK</a></li>
<li><a href="#Synergy-S5D9">Synergy S5D9</a></li>
<li><a href="#IBM-S_002f390">IBM S/390</a></li>
<li><a href="#Taihu">Taihu</a></li>
<li><a href="#Xilinx-Zynq-A9">Xilinx Zynq A9</a></li>
<li><a href="#ZOOM">ZOOM</a></li>
</ul>
<div class="section" id="Altera-10M50GHRD">
<h3 class="section">18.1 Altera 10M50GHRD</h3>
<span id="index-Altera-10M50GHRD"></span>

<p>Altera&reg; 10M50GHRD is a virtual platform in SweetAda, usable by
means of the QEMU emulator. This platform is based on a softcore Nios II&reg;
processor, implemented in real world in an FPGA.
</p>
<p>QEMU instantiates a few peripherals for this platform:
- 2 timers
- 1 16550-style UART
</p>
<p>By using libioemu, there are also 8 32-bit I/O ports available as widgets.
</p>
<p>CPU parameters are fixed at some particular addresses, as dictated by QEMU, and
already wrapped in the platform&rsquo;s configuration.in.
</p>
</div>
<div class="section" id="Amiga">
<h3 class="section">18.2 Amiga</h3>
<span id="index-Amiga"></span>

<p>The Amiga platform is the well-known machine based on the M68k venerable class
of CPU.
</p>
<p>The BSP is mostly based on an Amiga 2000 machine with OCS setup. Supported CPUs
are MC68010, MC68020, MC68030 and MC68040. The MC68000 is not supported due to the
lack of the VBR instructions, which does not allow to relocate exception and
interrupt vectors.
</p>
<p>In the context of SweetAda, Amiga code can be used both in a real machine and an
emulated machine by means of the FS-UAE emulator. The output kernel is a binary
image that should be used instead of the classic &quot;Kickstart&quot; ROM binary image.
Once you have burnt the kernel image in an EPROM, you can boot the Amiga with
your Ada code.
</p>
<p>Currently, Amiga platform is able to use some peripherals, like the OCS video,
the serial port and the A2065 network adapter (tested only in FS-UAE so far).
</p>
</div>
<div class="section" id="Arduino-Uno">
<h3 class="section">18.3 Arduino Uno</h3>
<span id="index-Arduino-Uno"></span>

<p>Arduino&reg; UNO is a very popular embedded board based on the
AVR class of MCU.
</p>
</div>
<div class="section" id="Atlas">
<h3 class="section">18.4 Atlas</h3>
<span id="index-Atlas"></span>

<p>Atlas is a PC-style board based on a PowerPC PPC604 CPU.
</p>
</div>
<div class="section" id="Terasic-DE10_002dLite">
<h3 class="section">18.5 Terasic DE10-Lite</h3>
<span id="index-Terasic-DE10_002dLite"></span>

<p>The DE10-Lite is an embedded board preoduced by Terasic, based on an Altera&reg;
FPGA, which runs a softcore Nios II&reg; processor.
</p>
</div>
<div class="section" id="DECstation-5000_002f133">
<h3 class="section">18.6 DECstation 5000/133</h3>
<span id="index-DECstation-5000_002f133"></span>

<p>DECstation 5000/133 is a famed workstation made by Digital&reg;.
</p>
<p>The output binary code is suitable to burn an EPROM, substituting the original one
in the main board of the workstation.
</p>
</div>
<div class="section" id="Digi-Connect-ME">
<h3 class="section">18.7 Digi Connect ME</h3>
<span id="index-Digi-Connect-ME"></span>

<p>The Digi Connect ME is a embedded networking module produced by Digi, containing
a NET+ARM CPU.
</p>
<p>The development is performed by using the JTAG port, and by using OpenOCD.
</p>
</div>
<div class="section" id="Dreamcast">
<h3 class="section">18.8 Dreamcast</h3>
<span id="index-Dreamcast"></span>

<p>SEGA&reg; Dreamcast is a home video game console based on an
Hitachi SH-4 CPU.
</p>
<p>This platform is only used as a template, in order to work with this kind
of CPU and test SweetAda in the maximum possible range of physical hardware.
</p>
<p>There are two ways to work with SweetAda on Dreamcast. One is to use the
true physical console, the other is by using the GXemul emulator.
</p>
<p>In order to work with the physical hardware, you need to create a CD-ROM
and to have the availability of a BBA Ethernet Adapter. The CD-ROM should be
burned with a little application that contains a minimal driver for the
BBA. This driver sits and waits for a program that should be downloaded
from your development host. Once you have a SweetAda kernel, the bba.tcl
utility provides a way to send the kernel to the console.
</p>
</div>
<div class="section" id="FRDM_002dKL46Z">
<h3 class="section">18.9 FRDM-KL46Z</h3>
<span id="index-FRDM_002dKL46Z"></span>

<p>FRDM-KL46Z (&quot;Freedom&quot;) is a little embedded board based on an ARM CPU.
</p>
</div>
<div class="section" id="GEMI">
<h3 class="section">18.10 GEMI</h3>
<span id="index-GEMI"></span>

<p>&quot;GEMI&quot; is a proprietary embedded board based on the Hitachi SH7032 CPU, available only
to the author of SweetAda, and thus is used solely as a template in order to work with
this kind of CPU and test SweetAda in the maximum possible range of physical hardware.
</p>
<p>SweetAda code runs in a Flash EPROM and is able to perform various activities,
like talking over a serial line, toggle memory-mapped I/Os and manage the
on-board RTC.
</p>
</div>
<div class="section" id="SiFive-HiFive-1">
<h3 class="section">18.11 SiFive HiFive 1</h3>
<span id="index-SiFive-HiFive-1"></span>

<p>The SiFive<sup>TM</sup> HiFive 1 is an embedded board based on a RISC-V&reg;
32-bit CPU.
</p>
<p>Following example is for a Rev B board and a Linux machine with OpenOCD.
</p>
<p>Once the target is configured, the &quot;session-start&quot; target activates an OpenOCD
session. This OpenOCD instance could remain active through the entire development
cycle.
</p>
<div class="example">
<pre class="example">$ make session-start
</pre></div>

<p>If OpenOCD is correctly installed, with proper settings in configuration.in, the
following terminal window should appear:
</p>
<img src="hifive1-openocd_server.png" alt="hifive1-openocd_server">

<p>OpenOCD will halt the CPU and will be sitting idle, waiting for a connection.
By issuing a &quot;make run&quot; shell command, the script (which is also used for the
previous command) will instruct OpenOCD to download the SweetAda code in the board
RAM, executing it from the low-level assembly start entry point. It is essential
to deactivate interrupts as fast as possible in the startup code, because the
halted program is most likely a default application which runs with interrupts
enabled, else when a timer IRQ is triggered an invalid program counter will be called.
</p>
<div class="example">
<pre class="example">$ make run
</pre></div>

<img src="hifive1-openocd_server-run.png" alt="hifive1-openocd_server-run">

<p>You should see the board cycling the multi-color LED through the R, G and B blinks.
</p>
</div>
<div class="section" id="Integrator_002fCP">
<h3 class="section">18.12 Integrator/CP</h3>
<span id="index-Integrator_002fCP"></span>

<p>The Integrator/CP is a virtual platform provided by QEMU, which mimics the real one,
produced by ARM&reg;.
</p>
<p>It features an ARM926EJ-S (LE mode) coupled with the following components:
</p><ul>
<li> SoC FPGA with system peripherals
</li><li> PL011 CLCD Controller
</li><li> LAN91C111 Ethernet interface controller
</li></ul>

</div>
<div class="section" id="LEON3">
<h3 class="section">18.13 LEON3</h3>
<span id="index-LEON3"></span>

<p>The LEON3 is a virtual platform provided by QEMU, which mimics a generic machine based
on the LEON3&reg; processor.
</p>
</div>
<div class="section" id="M5235BCC">
<h3 class="section">18.14 M5235BCC</h3>
<span id="index-M5235BCC"></span>

<p>M5235BCC is an embedded board based on the MCF5235 ColdFire processor.
</p>
</div>
<div class="section" id="ML605">
<h3 class="section">18.15 ML605</h3>
<span id="index-ML605"></span>

<p>ML605 is a virtual platform provided by QEMU, which mimics the real one.
</p>
</div>
<div class="section" id="MPC8306-SOM">
<h3 class="section">18.16 MPC8306 SOM</h3>
<span id="index-MPC8306-SOM"></span>

<p>MPC830x SOM (System on Module) is an embedded development board based on a
Freescale MPC830x CPU, produced by eInfochips. In this setup the MPC8306 is
the target CPU used.
</p>
<p>In order to use the SOM, you need CCS (CodeWarrior Connection Server). CCS is
part of CodeWarrior, so the installation of this software is highly recommended.
Note that you don&rsquo;t need to make CodeWarrior operative, you need just the installation
of the software to connect to the board via JTAG by using an USB TAP device.
</p>
<p>To proper setup CCS, the configuration.in provides some environment variables:
</p><ul>
<li> CCS_PREFIX: the path towards the installation of CCS (not including the &quot;bin&quot; subdirectory)
</li><li> CCS_NETSERVER_PORT: the TCP port used by libccs.tcl script library to connect to CCS via
a telnet session
</li><li> USBTAP_SN: the serial number of the CodeWarrior USB TAP JTAG device
</li></ul>

</div>
<div class="section" id="MPC8306-Switch">
<h3 class="section">18.17 MPC8306 Switch</h3>
<span id="index-MPC8306-Switch"></span>

<p>&quot;Switch&quot; is a proprietary embedded board based on the MPC8306 CPU, available only
to the author of SweetAda, and thus is used solely as a template in order to work with
this kind of CPU and test SweetAda in the maximum possible range of physical hardware.
</p>
<p>Prerequisites like those of MPC8306 SOM apply here, i.e. the CCS installation.
</p>
</div>
<div class="section" id="MPC8315e">
<h3 class="section">18.18 MPC8315e</h3>
<span id="index-MPC8315e"></span>

<p>MPC8315e is a proprietary embedded board based on the homonym PowerPC CPU, available only
to the author of SweetAda, and thus is used solely as a template in order to work with
this kind of CPU and test SweetAda in the maximum possible range of physical hardware.
</p>
</div>
<div class="section" id="MSP432P401R">
<h3 class="section">18.19 MSP432P401R</h3>
<span id="index-MSP432P401R"></span>

<p>The MSP432P401R is a litlle embedded board based on an ARM CPU.
</p>
</div>
<div class="section" id="MVME162_002d510A">
<h3 class="section">18.20 MVME162-510A</h3>
<span id="index-MVME162_002d510A"></span>

<p>The MVME162-510A is a VME board based on an MC68040 CPU.
</p>
</div>
<div class="section" id="Malta">
<h3 class="section">18.21 Malta</h3>
<span id="index-Malta"></span>

<p>&quot;Malta&quot; is a virtual platform provided by QEMU, which mimics the real one.
</p>
</div>
<div class="section" id="Memec-FX12">
<h3 class="section">18.22 Memec FX12</h3>
<span id="index-Memec-FX12"></span>

<p>The Memec FX12 is a little embedded module based on Xilinx&reg;
Virtex-4 FPGA equipped with an hard PPC405 core.
</p>
</div>
<div class="section" id="PC_002dx86">
<h3 class="section">18.23 PC-x86</h3>
<span id="index-PC_002dx86"></span>

<p>PC-x86 is a family of platforms based on the Intel x86-class 32-bit processor.
</p>
</div>
<div class="section" id="PC_002dx86_002d64">
<h3 class="section">18.24 PC-x86-64</h3>
<span id="index-PC_002dx86_002d64"></span>

<p>PC-x86-64 is a family of platforms based on Intel/AMD x86-64-class 64-bit processors.
</p>
</div>
<div class="section" id="QEMU-AArch64">
<h3 class="section">18.25 QEMU AArch64</h3>
<span id="index-QEMU-AArch64"></span>

<p>The QEMU AArch64 is a virtual platform provided by QEMU, which is based on an
ARM AArch64-class CPU.
</p>
</div>
<div class="section" id="QEMU-AVR">
<h3 class="section">18.26 QEMU AVR</h3>
<span id="index-QEMU-AVR"></span>

<p>The QEMU AVR is a virtual platform provided by QEMU, which is based on an
AVR-class CPU.
</p>
</div>
<div class="section" id="QEMU-MIPS">
<h3 class="section">18.27 QEMU MIPS</h3>
<span id="index-QEMU-MIPS"></span>

<p>The QEMU MIPS is a virtual platform provided by QEMU, which is based on an
MIPS-class CPU.
</p>
</div>
<div class="section" id="QEMU-RISC_002dV-32">
<h3 class="section">18.28 QEMU RISC-V 32</h3>
<span id="index-QEMU-RISC_002dV-32"></span>

<p>The QEMU RISC-V 32 is a virtual platform provided by QEMU, which is based on an
32-bit RISC-V-class CPU.
</p>
</div>
<div class="section" id="REF405EP">
<h3 class="section">18.29 REF405EP</h3>
<span id="index-REF405EP"></span>

<p>The REF405EP is a PowerPC PPC405EP reference platform; current support is only
for the emulated version provided in QEMU.
</p>
</div>
<div class="section" id="Raspberry-Pi-3">
<h3 class="section">18.30 Raspberry Pi 3</h3>
<span id="index-Raspberry-Pi-3"></span>

<p>The Raspberry Pi 3 Model B is a popular embedded board based on a Broadcom&reg;
BCM2387 64-bit quad-core ARM-class CPU.
</p>
<img src="rpi3-board.png" alt="rpi3-board">

<p>To work with SweetAda code, you should store the kernel binary in a bootable SDHC
memory card with a recognized filesystem layout.
</p>
<p>A working environment is formatting the SDHC and placing the SweetAda kernel in the
first partition, which must be FAT32 (ID=0xC), along with the proprietary bootstrap
files &quot;bootcode.bin&quot; and &quot;start.elf&quot; (which you can extract from one of the Linux
distribution available). Newer versions of bootcode.bin does not need the &quot;start.elf&quot;
file.
</p>
<p>The GPU of the SoC will boot the memory card by parsing the &quot;config.txt&quot; file, and
then will start the &quot;kernel.rom&quot; just loaded in the SDRAM.
</p>
<p>Then SweetAda takes control, running on the first core at EL1.
</p>
<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
In SweetAda terminology, &quot;kernel.rom&quot; not necessarily indicates a flat binary
memory image, in this case is an ELF executable ready to be loaded by the SoC bootloader
</p></td></tr></table>

<p>A Bash shell script in the platform directory, named &quot;createbootdevice.sh&quot;, will store
the files &quot;config.txt&quot; and &quot;kernel.rom&quot; in the memory card once it knows the UUID
(USDCARD_UUID) and the filesystem location (USDCARD_MOUNTPOINT), which you have to
specify in the configuration.in file (hence it is useful to format an SDHC and name it
with that UUID). If you have a system other than Linux, just put in place those files
with a manual file copy operation once you have visibility of the SDHC memory card.
</p>
</div>
<div class="section" id="SBC5206">
<h3 class="section">18.31 SBC5206</h3>
<span id="index-SBC5206"></span>

<p>The SBC5206 is a virtual platform provided by QEMU, which mimics an Arnewsh 5206
embedded board, based on the MCF5206 ColdFire processor.
</p>
</div>
<div class="section" id="SPARCstation-5">
<h3 class="section">18.32 SPARCstation 5</h3>
<span id="index-SPARCstation-5"></span>

<p>SPARCstation 5 is a famed workstation made by Sun&reg;. Beyond the
real hardware machine, SPARCstation 5 is also a machine emulated by QEMU.
</p>
<p>The output binary code is suitable to burn an EPROM, substituting the original one
in the main board of the workstation.
</p>
</div>
<div class="section" id="STM32F769I">
<h3 class="section">18.33 STM32F769I</h3>
<span id="index-STM32F769I"></span>

<p>The STM32F769I is a popular embedded board based on an ARM-class CPU.
</p>
</div>
<div class="section" id="Spartan-3A-EK">
<h3 class="section">18.34 Spartan 3A EK</h3>
<span id="index-Spartan-3A-EK"></span>

<p>The Spartan 3A EK is an embedded board based on a Xilinx&reg; Spartan-3A FPGA.
</p>
</div>
<div class="section" id="Spartan-3E-SK">
<h3 class="section">18.35 Spartan 3E SK</h3>
<span id="index-Spartan-3E-SK"></span>

<p>The Spartan 3E SK is an embedded board based on a Xilinx&reg; Spartan-3E FPGA.
</p>
</div>
<div class="section" id="Synergy-S5D9">
<h3 class="section">18.36 Synergy S5D9</h3>
<span id="index-Synergy-S5D9"></span>

<p>The Synergy PS5D9 is an embedded board from Renesas&reg;, equipped
with a ARM Cortex-M4 SoC.
</p>
<p>This platform can be directly programmed by means of OpenOCD support.
</p>
</div>
<div class="section" id="IBM-S_002f390">
<h3 class="section">18.37 IBM S/390</h3>
<span id="index-IBM-S_002f390"></span>

<p>S/390&reg; is the well-known family of mainframes produced by IBM&reg;.
</p>
<p>This platform has no practical use, because a casual user could find difficult
to have access to use such a machine. Despite that, it is fascinating
to do some form of Ada development, testing the quality of SweetAda with this
kind of computing device.
</p>
<p>Indeed, SweetAda use the Hercules emulator as a target. As well as all other
platforms, SweetAda does not rely on pre-existing software, and take the machine
out of reset (known in IBM jargon as IPL, &quot;Initial Program Loading&quot;) in order to
perform something from the scratch. There are two bootstrap options, an IPL from
tape and an IPL from hard disk (&quot;DASD&quot;).
</p>
<p>The application is limited to show some messages on an X3270 terminal. However,
this is done also with the aid of a minimal interrupt context.
</p>
</div>
<div class="section" id="Taihu">
<h3 class="section">18.38 Taihu</h3>
<span id="index-Taihu"></span>

<p>The Taihu is a virtual platform provided by QEMU, which mimics the real one,
based on a PowerPC PPC405 device.
</p>
</div>
<div class="section" id="Xilinx-Zynq-A9">
<h3 class="section">18.39 Xilinx Zynq A9</h3>
<span id="index-Xilinx-Zynq-A9"></span>

<p>The Xilinx&reg; Zynq A9 is a virtual platform provided by QEMU,
which mimics the real one.
</p>
</div>
<div class="section" id="ZOOM">
<h3 class="section">18.40 ZOOM</h3>
<span id="index-ZOOM"></span>

<p>ZOOM is a family of embedded board based on the MCF5373 ColdFire processor.
</p>
<hr>
</div>
</div>
<div class="chapter" id="IOEMU-scripting">
<div class="header">
<p>
Next: <a href="#References" accesskey="n" rel="next">References</a>, Previous: <a href="#Platform-descriptions" accesskey="p" rel="prev">Platform descriptions</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="IOEMU-scripting-1"></span><h2 class="chapter">19 IOEMU scripting</h2>

<p>The IOEMU facility allows configuration of a target emulator machine (but not
limited to) by specifying actions in a very basic script-like sequence of
assignments and statements. The same result could be obtained by execute a
shell script (perhaps specified in the RUN_COMMAND specifier of the platform
configuration.in file, but IOEMU scripting, coupled with runsweetada, is special
because it also defines the interface behaviour of the virtual I/Os.
</p>
<p>IOEMU configuration files are structured in declarations and sections.
</p>
<p>Declarations (ENV and SET) must come first, and their purposes are to declare
environment variables globally (ENV) or local to the file or a section (SET).
</p>
<p>Sections are directives, processed either by the runsweetada utility or the IOEMU
layer of the target emulator (QEMU/FS-UAE/GXemul).
</p>
<p>The START section is processed only by the runsweetada utility, which can be
instructed to execute the selected emulator, perhaps under the control of the GDB
debugger.
</p>
<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
When QEMU is running under heavy debugging output, it slows down noticeably.
This is why there are multiple assignments in some loops concerning the variable
&quot;Delay_Loop_Count&quot;.
</p></td></tr></table>

<table class="cartouche" border="1"><tr><td>
<p>NOTE:<br>
Occasionally, if QEMU starts not so quickly, chances are that GDB is ready to
communicate with the remote target when the emulator has not finished initialization.
In this case you could experience messages like:
</p>
<div class="example">
<pre class="example">Remote replied unexpectedly to 'vMustReplyEmpty': PacketSize=1000;qXfer:features: ...
</pre></div>

<p>Either restart everything from scratch (next time maybe the library loader will
pick thing from cache faster), or insert a SLEEP in the IOEMU script before start
GDB.
</p></td></tr></table>

<p>The configuration file is then processed again by the emulator. The IOEMU
section is used to configure the coordinates of the IOEMU window. When the
parser encounters the end of this section, it evaluates only these variables:
</p>
<ul>
<li> <pre class="verbatim">PANELX          window x-coordinate
</pre></li><li> <pre class="verbatim">PANELY          window y-coordinate
</pre></li><li> <pre class="verbatim">PANELWIDTH      window width in pixels
</pre></li><li> <pre class="verbatim">PANELHEIGHT     window height in pixels
</pre></li></ul>

<p>So, the only useful actions are to set these variables in order to accomodate
the window.
</p>
<p>All other sections are interpreted as specifications of the I/O features exposed by
the target emulator, in terms of serial ports or IOEMU virtual I/O ports that show
up as widgets. Every I/O port has a specific name and you can see its mapping in the
Ada code platform description (&quot;ioemu.ads&quot;). When the emulator starts, it advertises
the virtual I/Os in terms of port names, addresses and sizes.
</p>
<p>Inside the I/O port section you can thus set the type of widget used (a LED, a LEDBAR,
an hex DISPLAY), its color and its size.
</p>
<ul class="section-toc">
<li><a href="#IOEMU-objects" accesskey="1">IOEMU objects</a></li>
<li><a href="#IOEMU-keywords" accesskey="2">IOEMU keywords</a></li>
<li><a href="#IOEMU-automatic-variables" accesskey="3">IOEMU automatic variables</a></li>
</ul>
<div class="section" id="IOEMU-objects">
<h3 class="section">19.1 IOEMU objects</h3>
<span id="index-IOEMU-objects"></span>

<p>Strings<br>
</p>
<p>String exists when you write literals inside double-quotes. Use a backslash
to enter a special characters.
</p>
<p>Variables<br>
</p>
<p>Variables are strings. Numeric values are converted to string. If you want
to dereference a variable, use a &quot;$&quot; prefix followed by the name of the variable.
Use braces to isolate variables when concatenating them with literals, like in
&quot;${PORT1}&quot;. Note that dereferencing takes place only within double-quotes.
There are three types of variable in IOEMU scripting: environment, global and local.
Environment variables are available all the times, and are automatically imported.
You can create an environment variable (being passed to child executable) with the
ENV &lt;variable&gt; &lt;value&gt; directive. Global variables are created with the
SET &lt;variable&gt; &lt;value&gt; directive. Variables declared within sections are local
to that scope and ceased to exist when the parser leave the section.
</p>
<p>Boolean expressions<br>
</p>
<ul>
<li> <pre class="verbatim">FALSE | TRUE
</pre></li><li> <pre class="verbatim">NOT &lt;expr&gt;
</pre></li><li> <pre class="verbatim">&lt;expr&gt; AND &lt;expr&gt;
</pre></li><li> <pre class="verbatim">&lt;expr&gt; OR &lt;expr&gt;
</pre></li><li> <pre class="verbatim">&lt;string&gt; = &lt;string&gt;
</pre></li><li> <pre class="verbatim">DEFINED(&lt;string&gt;)
</pre></li></ul>

<p>Parens &rsquo;(&rsquo; and &rsquo;)&rsquo; state the priority of expression grouping.
</p>
</div>
<div class="section" id="IOEMU-keywords">
<h3 class="section">19.2 IOEMU keywords</h3>
<span id="index-IOEMU-keywords"></span>

<p>ENV &lt;variable_name&gt; &lt;variable_value&gt;
Defines a variable to be added to the environment.
</p>
<p>SET &lt;variable_name&gt; &lt;variable_value&gt;
Defines a variable in the current scope (global in the script if outer of any
section, or local to a section).
</p>
<p>SECTION &lt;name&gt;<br>
Introduces a section. Section names could be &quot;START&quot;, &quot;IOEMU&quot; (to configure generic
properties of the IOEMU layer, like window positioning and size) or an I/O port or
communication peripheral exported by the target machine being emulated.
</p>
<p>ENDSECT<br>
Declares the end of a section.
</p>
<p>IF-THEN-ELSE-ELIF-ENDIF<br>
Classic decision structure. The test condition must be a boolean expression.
IF structures can be nested. Note that IF structures can be used only inside
sections.
</p>
<p>ARGS arg[,arg...]<br>
ARGS is a special directive. When you declare an ARGS directive, strings are
added sequentially to the array that carries arguments for the next EXEC/EXEA
command. You can add arguments to the desired executable at various points
of a section, and decided which arguments must be selected. Once the EXEC/EXEA
instruction is processed, the ARGS array is reset to empty.
</p>
<p>CHDIR &lt;directory_path&gt;<br>
Change the working directory. Note that this command is available only inside
the START section.
</p>
<p>EXEC &lt;executable&gt;<br>
Executes an executable. Strings collected with the ARGS directive will be passed
as arguments. The script control flow does not proceed further until the executable
returns.
</p>
<p>EXEA &lt;executable&gt;<br>
Same as EXEC, but the executable is launched in the background, so script control
flow can proceed almost immediately.
</p>
<p>SLEEP &lt;ms&gt;<br>
Suspends the control flow execution for the amount of time specified in ms.
</p>
<p>SYSTEM &lt;command&gt;<br>
Executes a generic system command.
</p>
<p>WIDGET &lt;widget_type&gt; @x,y NAME &lt;name&gt;<br>
Associates a graphic widget with the I/O port declared in the section just
introduced, displaying it at coordinates x,y, with label &lt;name&gt;. Available
widgets are
</p><ul>
<li> <pre class="verbatim">LED
</pre></li><li> <pre class="verbatim">LEDBAR[8|16|32|64]
</pre></li><li> <pre class="verbatim">DISPLAY[8|16|32|64]
</pre></li><li> <pre class="verbatim">BUTTON
</pre></li><li> <pre class="verbatim">SWITCH, SWITCH8
</pre></li></ul>

<p>LED and LEDBARs widgets have COLOR_x attributes:
</p>
<ul>
<li> <pre class="verbatim">COLOR_RED
</pre></li><li> <pre class="verbatim">COLOR_GREEN
</pre></li><li> <pre class="verbatim">COLOR_BLUE
</pre></li><li> <pre class="verbatim">COLOR_YELLOW
</pre></li><li> <pre class="verbatim">COLOR_WHITE
</pre></li></ul>

<p>LED widgets have also:
</p>
<ul>
<li> <pre class="verbatim">LED_SMALL      draw a small rectangle instead of an icon
</pre></li><li> <pre class="verbatim">LED_PULSE      make the LED persistent for a small amount of time when turned off
</pre></li><li> <pre class="verbatim">LED_PULSE_FAST the same as LED_PULSE, but with a very short persistence
</pre></li></ul>

</div>
<div class="section" id="IOEMU-automatic-variables">
<h3 class="section">19.3 IOEMU automatic variables</h3>
<span id="index-IOEMU-automatic-variables"></span>

<p>IOEMU creates some implicit variables during its execution:
</p>
<ul>
<li> __THISFILE__<br>
Carries the name of the configuration file being processed. This way, you can export
this variable and pass it to a emulator, that thus could use this same configuration
file. Note that this is quite mandatory, because SweetAda emulators loads the
IOEMU shared library and the configuration file using environment variables.
</li><li> __SERIALPORTDEVICE__ (Linux only)<br>
Carries the name of the virtual device associated with an emulator physical serial port.
When you are using QEMU there is no need to use this variable, because the emulator
maps physical serial ports to known TCP ports declared within command line arguments,
whereas the FS-UAE emulator creates on-the-fly a virtual serial port that cannot be
known before execution.
</li></ul>

<hr>
</div>
</div>
<div class="chapter" id="References">
<div class="header">
<p>
Next: <a href="#Index" accesskey="n" rel="next">Index</a>, Previous: <a href="#IOEMU-scripting" accesskey="p" rel="prev">IOEMU scripting</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="References-1"></span><h2 class="chapter">20 References</h2>
<span id="index-References"></span>

<p>Home page<br>
<a href="https://www.sweetada.org">https://www.sweetada.org</a>
</p>
<p>SourceForge repository<br>
<a href="https://sourceforge.net/projects/sweetada/">https://sourceforge.net/projects/sweetada/</a>
</p>
<p>GitHub repository<br>
<a href="https://github.com/gabriele-galeotti/SweetAda">https://github.com/gabriele-galeotti/SweetAda</a>
</p>
<hr>
</div>
<div class="unnumbered" id="Index">
<div class="header">
<p>
Previous: <a href="#References" accesskey="p" rel="prev">References</a>, Up: <a href="#Top" accesskey="u" rel="up">SweetAda</a> &nbsp; [<a href="#Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Index-1"></span><h2 class="unnumbered">Index</h2>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-X"><b>X</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Z"><b>Z</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-A">A</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Altera-10M50GHRD">Altera 10M50GHRD</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Amiga">Amiga</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arduino-Uno">Arduino Uno</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Atlas">Atlas</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-C">C</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-configuration">configuration</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Configuration">Configuration</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-core">core</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-core-complex">The core complex</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-D">D</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-DECstation-5000_002f133">DECstation 5000/133</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Digi-Connect-ME">Digi Connect ME</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Dreamcast">Dreamcast</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-E">E</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-elftool">elftool</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Toolchain-tools">Toolchain tools</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Emulators">Emulators</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Emulators">Emulators</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Environment-notes">Environment notes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Host-environment">Host environment</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-F">F</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-FRDM_002dKL46Z">FRDM-KL46Z</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-G">G</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-GCC-wrapper">GCC wrapper</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Toolchain-tools">Toolchain tools</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GEMI">GEMI</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-General-advice">General advice</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Host-environment">Host environment</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GNAT-wrapper">GNAT wrapper</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Toolchain-tools">Toolchain tools</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-GPRbuild">GPRbuild</a>:</td><td>&nbsp;</td><td valign="top"><a href="#GPRbuild-mode">GPRbuild mode</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-I">I</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-IBM-S_002f390">IBM S/390</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Installation-prerequisites">Installation prerequisites</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Host-environment">Host environment</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Integrator_002fCP">Integrator/CP</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-IOEMU-automatic-variables">IOEMU automatic variables</a>:</td><td>&nbsp;</td><td valign="top"><a href="#IOEMU-scripting">IOEMU scripting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-IOEMU-keywords">IOEMU keywords</a>:</td><td>&nbsp;</td><td valign="top"><a href="#IOEMU-scripting">IOEMU scripting</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-IOEMU-objects">IOEMU objects</a>:</td><td>&nbsp;</td><td valign="top"><a href="#IOEMU-scripting">IOEMU scripting</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-L">L</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-LEON3">LEON3</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LibGCC">LibGCC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#LibGCC">LibGCC</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-M">M</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-M5235BCC">M5235BCC</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Makefile-targets">Makefile targets</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Makefile-targets">Makefile targets</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Malta">Malta</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Memec-FX12">Memec FX12</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Menu-front_002dends">Menu front-ends</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Menu-front_002dends">Menu front-ends</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ML605">ML605</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPC8306-SOM">MPC8306 SOM</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPC8306-Switch">MPC8306 Switch</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MPC8315e">MPC8315e</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MSP432P401R">MSP432P401R</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-MVME162_002d510A">MVME162-510A</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-O">O</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-optimizations">optimizations</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Optimizations">Optimizations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Overview">Overview</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Overview">Overview</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-P">P</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-PC_002dx86">PC-x86</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-PC_002dx86_002d64">PC-x86-64</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-platform">platform</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Anatomy-of-a-platform">Anatomy of a platform</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-Q">Q</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-QEMU-AArch64">QEMU AArch64</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-QEMU-AVR">QEMU AVR</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-QEMU-MIPS">QEMU MIPS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-QEMU-RISC_002dV-32">QEMU RISC-V 32</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-R">R</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Raspberry-Pi-3">Raspberry Pi 3</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-REF405EP">REF405EP</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-References">References</a>:</td><td>&nbsp;</td><td valign="top"><a href="#References">References</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RTS">RTS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Building-the-RTS">Building the RTS</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-runsweetada">runsweetada</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Toolchain-tools">Toolchain tools</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-S">S</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-SBC5206">SBC5206</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SiFive-HiFive-1">SiFive HiFive 1</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-SPARCstation-5">SPARCstation 5</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Spartan-3A-EK">Spartan 3A EK</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Spartan-3E-SK">Spartan 3E SK</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-STM32F769I">STM32F769I</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Synergy-S5D9">Synergy S5D9</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-T">T</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Taihu">Taihu</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Terasic-DE10_002dLite">Terasic DE10-Lite</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Testing-the-installation">Testing the installation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Host-environment">Host environment</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-toolchains">toolchains</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Toolchains">Toolchains</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-X">X</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Xilinx-Zynq-A9">Xilinx Zynq A9</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Index_cp_letter-Z">Z</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-ZOOM">ZOOM</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Platform-descriptions">Platform descriptions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-X"><b>X</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index_cp_letter-Z"><b>Z</b></a>
 &nbsp; 
</td></tr></table>


</div>
</div>



</body>
</html>
